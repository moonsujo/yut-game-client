/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import wolfVertexShader from './vertexSparkling.glsl'
import wolfFragmentShader from './fragmentSparkling.glsl'
import { useEffect, useMemo, useRef } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";

export default function BullConstellation(props) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/models/bull-constellation-thin.glb')

  const count = nodes.BezierCurve001.geometry.attributes.position.count;
  const randomArray = new Float32Array(count/4);
  const positionArray = new Float32Array((count/4)*3);
  
  for (let i = 0; i < count/4; i++) {
    randomArray[i] = Math.random() * 2.0 * Math.PI;
    positionArray[i*3] = nodes.BezierCurve001.geometry.attributes.position.array[(i*12*3)]
    positionArray[i*3+1] = nodes.BezierCurve001.geometry.attributes.position.array[(i*12*3)+1]
    positionArray[i*3+2] = nodes.BezierCurve001.geometry.attributes.position.array[(i*12*3)+2]
  }

  const { gl } = useThree();
  gl.setPixelRatio(Math.min(window.devicePixelRatio, 1))

  const uniforms = useMemo(() => ({
    uTime: { value: 0 },
  }), []);

  const shaderRef = useRef();
  useFrame((state, delta) => {
    if (shaderRef.current) {
      shaderRef.current.uniforms.uTime.value = state.clock.elapsedTime;
    }
  })

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene" scale={[1, 0.001, 1]} position={[0, -1, 0]} rotation={[Math.PI/2, 0, 0]}>
        <points>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={nodes.BezierCurve001.geometry.attributes.position.count/4/3}
              array={positionArray}
              itemSize={3}
            />
            <bufferAttribute
              attach="attributes-aRandom"
              count={count/4}
              array={randomArray}
              itemSize={1}
            />
          </bufferGeometry>
          <shaderMaterial
            blending={THREE.AdditiveBlending}
            depthWrite={false}
            vertexColors={true}
            vertexShader={wolfVertexShader}
            fragmentShader={wolfFragmentShader}
            ref={shaderRef}
            uniforms={uniforms}
          />
        </points>
      </group>
    </group>
  )
}
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import vertexShader from './vertex.glsl'
import fragmentShader from './fragment.glsl'
import { useThree } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import gsap from 'gsap';

export default function useStarRoll() {
  const { nodes } = useGLTF('/models/star.glb')

  const { scene } = useThree();

  const sizes = {
    width: window.innerWidth,
    height: window.innerHeight,
    pixelRatio: Math.min(window.devicePixelRatio, 2)
  }
  
  sizes.resolution = new THREE.Vector2(sizes.width * sizes.pixelRatio, sizes.height * sizes.pixelRatio)
  window.addEventListener('resize', () =>
  {
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight
    sizes.pixelRatio = Math.min(window.devicePixelRatio, 2)
    sizes.resolution.set(sizes.width * sizes.pixelRatio, sizes.height * sizes.pixelRatio)
  })

  const { gl } = useThree();
  gl.setSize(sizes.width, sizes.height)
  gl.setPixelRatio(sizes.pixelRatio)

  function RollStar({ 
    position, 
    rotation, 
    scale, 
    omitFactor=4, 
    size=0.01, 
    color, 
    duration=3,
    speedX=-8.0,
    speedY=4.0
  }) {

    let geometry
    let material

    const count = nodes.star.geometry.attributes.position.count;
    const reducedCount = Math.floor(count/omitFactor)
    const positionArray = new Float32Array(reducedCount*3);
    geometry = new THREE.BufferGeometry()
    
    for (let i = 0; i < reducedCount; i++) {
      positionArray[i*3] = nodes.star.geometry.attributes.position.array[(i*omitFactor*3)]
      positionArray[i*3+1] = nodes.star.geometry.attributes.position.array[(i*omitFactor*3)+1]
      positionArray[i*3+2] = nodes.star.geometry.attributes.position.array[(i*omitFactor*3)+2]
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positionArray, 3))

    material = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: {
        uSize: new THREE.Uniform(size), // needs the THREE.Uniform object
        uResolution: new THREE.Uniform(sizes.resolution),
        uColor: new THREE.Uniform(color),
        uProgress: new THREE.Uniform(0),
        uSpeedX: new THREE.Uniform(speedX),
        uSpeedY: new THREE.Uniform(speedY)
      },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      depthTest: true
    })

    const points = new THREE.Points(geometry, material)
    points.position.copy(position)
    points.rotation.set(rotation.x, rotation.y, rotation.z)
    points.scale.set(scale, scale, scale)
    const destroy = () => {
      scene.remove(points)
      geometry.dispose()
      material.dispose()
    }

    gsap.to(
      material.uniforms.uProgress,
      { value: 1, duration, ease: 'linear', onComplete: destroy }
    )
    
    scene.add(points)
  }

  return [RollStar]
}
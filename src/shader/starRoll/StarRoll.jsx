/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import vertexShader from './vertex.glsl'
import fragmentShader from './fragment.glsl'
import { useThree } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import gsap from 'gsap';
import { useWindowSize } from "../../hooks/useWindowSize";

export default function useStarRoll() {
  const { nodes } = useGLTF('/models/star.glb')
  const { scene } = useThree();
  
  // Use shared sizes object - no resize listener needed
  const sizes = useWindowSize();

  function RollStar({ 
    position, 
    rotation, 
    scale, 
    omitFactor=4, 
    size=0.01, 
    color, 
    duration=3,
    speedX=-8.0,
    speedY=4.0,
    shiny=false
  }) {

    let geometry
    let material

    const count = nodes.star.geometry.attributes.position.count;
    const reducedCount = Math.floor(count/omitFactor)
    const positionArray = new Float32Array(reducedCount*3);
    geometry = new THREE.BufferGeometry()
    
    for (let i = 0; i < reducedCount; i++) {
      positionArray[i*3] = nodes.star.geometry.attributes.position.array[(i*omitFactor*3)]
      positionArray[i*3+1] = nodes.star.geometry.attributes.position.array[(i*omitFactor*3)+1]
      positionArray[i*3+2] = nodes.star.geometry.attributes.position.array[(i*omitFactor*3)+2]
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positionArray, 3))

    material = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: {
        uSize: new THREE.Uniform(size), // needs the THREE.Uniform object
        uResolution: new THREE.Uniform(sizes.resolution),
        uColor: new THREE.Uniform(color),
        uProgress: new THREE.Uniform(0),
        uSpeedX: new THREE.Uniform(speedX),
        uSpeedY: new THREE.Uniform(speedY),
        uShiny: new THREE.Uniform(shiny ? 1.0 : 0.0),
      },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      depthTest: true
    })

    const points = new THREE.Points(geometry, material)
    points.position.copy(position)
    points.rotation.set(rotation.x, rotation.y, rotation.z)
    points.scale.set(scale, scale, scale)
    const destroy = () => {
      scene.remove(points)
      geometry.dispose()
      material.dispose()
    }

    gsap.to(
      material.uniforms.uProgress,
      { value: 1, duration, ease: 'linear', onComplete: destroy }
    )
    
    scene.add(points)
  }

  return [RollStar]
}
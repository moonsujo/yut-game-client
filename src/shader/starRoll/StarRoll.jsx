/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import vertexShader from './vertex.glsl'
import fragmentShader from './fragment.glsl'
import { useThree } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import gsap from 'gsap';

export default function useStarRoll() {
  const { nodes } = useGLTF('/models/star.glb')

  const { scene } = useThree();

  const sizes = {
    width: window.innerWidth,
    height: window.innerHeight,
    pixelRatio: Math.min(window.devicePixelRatio, 2)
  }
  
  sizes.resolution = new THREE.Vector2(sizes.width * sizes.pixelRatio, sizes.height * sizes.pixelRatio)
  window.addEventListener('resize', () =>
  {
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight
    sizes.pixelRatio = Math.min(window.devicePixelRatio, 2)
    sizes.resolution.set(sizes.width * sizes.pixelRatio, sizes.height * sizes.pixelRatio)
  })

  const { gl } = useThree();
  gl.setSize(sizes.width, sizes.height)
  gl.setPixelRatio(sizes.pixelRatio)

  // each one is one star
  // expand
  // roll across the screen
  // apply rotation with cos and sin to position
    // radius, uTime
  // contract
  // run for x counts
  function RollStar({ position, size=1, scale=1, color }) {

    console.log('roll star')
    let geometry
    let material

    const count = nodes.star.geometry.attributes.position.count;
    const positionArray = new Float32Array((count)*3);
    geometry = new THREE.BufferGeometry()
    
    for (let i = 0; i < count; i++) {
      positionArray[i*3] = nodes.star.geometry.attributes.position.array[(i*3)]
      positionArray[i*3+1] = nodes.star.geometry.attributes.position.array[(i*3)+1]
      positionArray[i*3+2] = nodes.star.geometry.attributes.position.array[(i*3)+2]
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positionArray, 3))

    material = new THREE.ShaderMaterial({
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: {
          uSize: new THREE.Uniform(size), // needs the THREE.Uniform object
          uScale: new THREE.Uniform(scale),
          uResolution: new THREE.Uniform(sizes.resolution),
          uColor: new THREE.Uniform(color),
          uProgress: new THREE.Uniform(0)
      },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      depthTest: true
    })

    const points = new THREE.Points(geometry, material)
    points.position.copy(position)
    const destroy = () => {
      scene.remove(points)
      geometry.dispose()
      material.dispose()
    }

    gsap.to(
      material.uniforms.uProgress,
      { value: 1, duration: 3, ease: 'linear', onComplete: destroy }
    )
    
    scene.add(points)
  }

  return [RollStar]
}